***************
Duck Typing ka matlab hai ki aap kisi object ko uski actual type se zyada uske behavior ke basis pe treat karte hain. Python is concept ko dynamically implement karta hai, jo program ko zyada flexible aur modular banaata hai.
Python ek dynamic language hai, matlab hum types ko runtime pe check karte hain, na ki compile-time pe. Yeh Duck Typing ko asaan banata hai.
class Bird:
    def fly(self):
        print("Bird is flying")

class Airplane:
    def fly(self):
        print("Airplane is flying")

def let_it_fly(flyable):
    flyable.fly()  # Hum yaha par object ka type check nahi kar rahe
                  # Bas yeh dekh rahe hain ki fly() method hai

# Creating objects
bird = Bird()
plane = Airplane()

# Let both objects "fly"
let_it_fly(bird)   # Output: Bird is flying
let_it_fly(plane)  # Output: Airplane is flying



Duck Typing Kaise Kaam Karta Hai?
Python mein, aapko explicit type declaration ya inheritance ki zarurat nahi hoti. Jab tak object ek certain method ko implement karta hai
, aap us object ko us type ka samajh sakte hain, chahe wo type uss class ka ho ya nahi.
**************************************************************************
operator overloading  :
Operator Overloading ek powerful feature hai Python ka jo polymorphism ko implement karta hai
class ComplexNumber:
    def __init__(self, r, i):
        self.real = r
        self.imaginary = i

    def __add__(self, other):
        
        return f"{self.real + other.real}+ {self.imaginary + other.imaginary}i"

    def __repr__(self):
        # String representation of the complex number
        return f"{self.real} + {self.imaginary}i"


c1 = ComplexNumber(1, 2)
c2 = ComplexNumber(4, 5)


result = c1 + c2   # This calls the __add__ method


print(result)  # Output: 5 + 7i
***********************************
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # Overloading the '>' operator using the __gt__ method
    def __gt__(self, other):
        if self.age > other.age:
            return True
        else:
            return False

# Creating Person objects
p1 = Person("Ram", 32)
p2 = Person("Shyam", 23)

# Using the overloaded '>' operator
if p1 > p2:
    print(f"{p1.name} is older than {p2.name}")
else:
    print(f"{p2.name} is older than {p1.name}")


********************************************************
Method Overriding (Runtime Polymorphism)

class Animal:
    def sound(self):
        print("Animal makes a sound")

class Dog(Animal):
    def sound(self):  # Overriding the sound method
        print("Dog barks")

class Cat(Animal):
    def sound(self):  # Overriding the sound method
        print("Cat meows")

# Instantiate objects
animal = Animal()
dog = Dog()
cat = Cat()

# Polymorphic behavior: the sound method works differently based on the object
animals = [animal, dog, cat]
for animal in animals:
    animal.sound()
********************************************************************************************

