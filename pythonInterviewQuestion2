***************
Duck Typing ka matlab hai ki aap kisi object ko uski actual type se zyada uske behavior ke basis pe treat karte hain. Python is concept ko dynamically implement karta hai, jo program ko zyada flexible aur modular banaata hai.
Python ek dynamic language hai, matlab hum types ko runtime pe check karte hain, na ki compile-time pe. Yeh Duck Typing ko asaan banata hai.
class Bird:
    def fly(self):
        print("Bird is flying")

class Airplane:
    def fly(self):
        print("Airplane is flying")

def let_it_fly(flyable):
    flyable.fly()  # Hum yaha par object ka type check nahi kar rahe
                  # Bas yeh dekh rahe hain ki fly() method hai

# Creating objects
bird = Bird()
plane = Airplane()

# Let both objects "fly"
let_it_fly(bird)   # Output: Bird is flying
let_it_fly(plane)  # Output: Airplane is flying



Duck Typing Kaise Kaam Karta Hai?
Python mein, aapko explicit type declaration ya inheritance ki zarurat nahi hoti. Jab tak object ek certain method ko implement karta hai
, aap us object ko us type ka samajh sakte hain, chahe wo type uss class ka ho ya nahi.
**************************************************************************
operator overloading  :
Operator Overloading ek powerful feature hai Python ka jo polymorphism ko implement karta hai
class ComplexNumber:
    def __init__(self, r, i):
        self.real = r
        self.imaginary = i

    def __add__(self, other):
        
        return f"{self.real + other.real}+ {self.imaginary + other.imaginary}i"

    def __repr__(self):
        # String representation of the complex number
        return f"{self.real} + {self.imaginary}i"


c1 = ComplexNumber(1, 2)
c2 = ComplexNumber(4, 5)


result = c1 + c2   # This calls the __add__ method


print(result)  # Output: 5 + 7i
***********************************
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # Overloading the '>' operator using the __gt__ method
    def __gt__(self, other):
        if self.age > other.age:
            return True
        else:
            return False

# Creating Person objects
p1 = Person("Ram", 32)
p2 = Person("Shyam", 23)

# Using the overloaded '>' operator
if p1 > p2:
    print(f"{p1.name} is older than {p2.name}")
else:
    print(f"{p2.name} is older than {p1.name}")


********************************************************
Method Overriding (Runtime Polymorphism)

class Animal:
    def sound(self):
        print("Animal makes a sound")

class Dog(Animal):
    def sound(self):  # Overriding the sound method
        print("Dog barks")

class Cat(Animal):
    def sound(self):  # Overriding the sound method
        print("Cat meows")

# Instantiate objects
animal = Animal()
dog = Dog()
cat = Cat()

# Polymorphic behavior: the sound method works differently based on the object
animals = [animal, dog, cat]
for animal in animals:
    animal.sound()
********************************************************************************************
Shallow copy ka matlab hai sirf reference (पता) ka copy hona, actual object ka nahi. Iska matlab hai ki
 agar aap kisi object ka shallow copy banate hain, to dono objects (original aur copied) memory mein same nested objects ko refer karenge.

import copy

# Original List (Nested List)
original_list = [[1, 2, 3], [4, 5, 6]]

# Shallow Copy
shallow_copied_list = copy.copy(original_list)

# Change original list ka ek nested element
original_list[0][1] = 99

# Output dekhein
print("Original List:", original_list)  
print("Shallow Copied List:", shallow_copied_list)  
***************
Agar object ke andar nested mutable objects hain (jaise lists, dictionaries), to unka reference copy hota hai, na ki naya object banta hai.
Ek object me change karne se doosre object me bhi reflection hota hai, jo kabhi-kabhi unexpected behavior cause kar sakta hai.
*****************
Deep copy ka matlab hota hai poora naya object create karna, jisme nested objects bhi naye memory locations par store hote hain.

import copy

# Original List (Nested List)
original_list = [[1, 2, 3], [4, 5, 6]]

# Deep Copy
deep_copied_list = copy.deepcopy(original_list)

# Change original list ka ek nested element
original_list[0][1] = 99

# Output dekhein
print("Original List:", original_list)  
print("Deep Copied List:", deep_copied_list)  
******************************************************

Feature	Shallow Copy (ऊपरी कॉपी)	Deep Copy (गहरी कॉपी)
Memory Allocation	Sirf outer object naya banta hai	Outer aur andar ke nested objects bhi naye bante hain
Reference Sharing	Inner (nested) objects ka reference copy hota hai	Pure structure ka naya instance banta hai
Impact of Change	Ek object me change karne se dusre object me bhi change ho jata hai (agar nested object change ho raha ho)	Ek object me change ka dusre object pe koi effect nahi hota
Performance	Faster, because sirf reference copy hota hai	Slower, because poora naya object create hota hai
Use Case	Jab nested objects change nahi honge	Jab humein independent copy chahiye
*************************************




