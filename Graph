
*****************
graph
directed graph and undirected graph
tree is also a graph
cycles in graph
degree in graph(indegree,outdegree)
minimum spanning tree

graph representation
adjacency matrix

undirected graph is symmetric on a diagonal  in case of adjacency matrix(v*v)->v stand for vertex
   
Ajacency list



# Create an adjacency list using a dictionary
graph = {}

# Helper function to add an edge to the adjacency list
def add_edge(graph, src, dest):
    if src not in graph:
        graph[src] = []  # Add the source node if not present
    if dest not in graph:
        graph[dest] = []  # Add the destination node if not present
    graph[src].append(dest)  # Add the destination to the source's adjacency list

# Add edges to the graph
add_edge(graph, 0, 1)
add_edge(graph, 0, 2)
add_edge(graph, 1, 2)
add_edge(graph, 2, 3)
add_edge(graph, 3, 3)

# Print the adjacency list
for node, neighbors in graph.items():
    print(f"{node} -> {neighbors}")

0 -> [1, 2]
1 -> [2]
2 -> [3]
3 -> [3]


Let's go through each call to add_edge:
add_edge(graph, 0, 1):
src = 0, dest = 1.
0 is not in graph, so graph[0] = [].
1 is not in graph, so graph[1] = [].
Append 1 to graph[0].
Result: graph = {0: [1], 1: []}.
add_edge(graph, 0, 2):
src = 0, dest = 2.
0 is already in graph.
2 is not in graph, so graph[2] = [].
Append 2 to graph[0].
Result: graph = {0: [1, 2], 1: [], 2: []}.
add_edge(graph, 1, 2):
src = 1, dest = 2.
1 is already in graph.
2 is already in graph.
Append 2 to graph[1].
Result: graph = {0: [1, 2], 1: [2], 2: []}.
add_edge(graph, 2, 3):
src = 2, dest = 3.
2 is already in graph.
3 is not in graph, so graph[3] = [].
Append 3 to graph[2].
Result: graph = {0: [1, 2], 1: [2], 2: [3], 3: []}.
add_edge(graph, 3, 3):
src = 3, dest = 3.
3 is already in graph.
Append 3 to graph[3].
Result: graph = {0: [1, 2], 1: [2], 2: [3], 3: [3]}.
****************************************************************************************
Is there any way we can find that it is a graph question
jis entity ki bat ho rahi hai woh numbred hogi most of times
ex->courses de rakha hai -->n
they are numbred 0 to (n-1)
relation ki bat kar rhi ho ->hinting toward edge of the graph
directly puchuega topic se
***********
from collections import defaultdict
adj = defaultdict(list)
prerequisites = [[1, 0], [2, 0], [3, 1], [3, 2]]
for vec in prerequisites:
    u = vec[0]  # Source node
    v = vec[1]  # Destination node
    adj[u].append(v)  # Add the edge to the adjacency list
for node, neighbors in adj.items():
    print(f"{node} -> {neighbors}")

******************************************************************************************************
Travesal in graph
*******
dfs and bfs
*********
from collections import defaultdict

class Solution:
    
    #Function to return a list containing the DFS traversal of the graph.
    def dfsOfGraph(self, adj):
        # code here
        adjlist=defaultdict(list)
        for i in range(len(adj)):
            for j in range(len(adj[i])):
                adjlist[i].append(adj[i][j])
                
        
        def dfs(adjlist,visited,u):
            visited[u]=True
            ans.append(u)
            for v in adjlist[u]:
                if not visited[v]:
                    dfs(adjlist,visited,v)
            
        
        ans=[]
        visited=[False]*len(adjlist)
        dfs(adjlist,visited,0)
        return ans
***********************************

in dfs traversal the arrow is moving in this way
-> -> -> -> ->
******************************************************************************
bfs is used in shortest path
***********
from collections import defaultdict,deque
from typing import List

class Solution:
    # Function to return Breadth First Traversal of given graph.
    def bfsOfGraph(self, adj: List[List[int]]) -> List[int]:
        adjlist=defaultdict(list)
        for i in range(len(adj)):
            for j in range(len(adj[i])):
                adjlist[i].append(adj[i][j])
                
        
        def bfs(adjlist,visited,u):
            queue=deque()
            queue.append(u)
            visited[u]=True
            
            ans.append(u)
            while(queue):
                u=queue.popleft()
                
                for v in adjlist[u]:
                    if not visited[v]:
                        queue.append(v)
                        visited[v]=True
                        ans.append(v)
                
            
        
        ans=[]
        visited=[False]*len(adj)
        bfs(adjlist,visited,0)
        return ans
***************************************************


