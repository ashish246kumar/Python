
*****************
graph
directed graph and undirected graph
tree is also a graph
cycles in graph
degree in graph(indegree,outdegree)
minimum spanning tree

graph representation
adjacency matrix

undirected graph is symmetric on a diagonal  in case of adjacency matrix(v*v)->v stand for vertex
   
Ajacency list



# Create an adjacency list using a dictionary
graph = {}

# Helper function to add an edge to the adjacency list
def add_edge(graph, src, dest):
    if src not in graph:
        graph[src] = []  # Add the source node if not present
    if dest not in graph:
        graph[dest] = []  # Add the destination node if not present
    graph[src].append(dest)  # Add the destination to the source's adjacency list

# Add edges to the graph
add_edge(graph, 0, 1)
add_edge(graph, 0, 2)
add_edge(graph, 1, 2)
add_edge(graph, 2, 3)
add_edge(graph, 3, 3)

# Print the adjacency list
for node, neighbors in graph.items():
    print(f"{node} -> {neighbors}")

0 -> [1, 2]
1 -> [2]
2 -> [3]
3 -> [3]


Let's go through each call to add_edge:
add_edge(graph, 0, 1):
src = 0, dest = 1.
0 is not in graph, so graph[0] = [].
1 is not in graph, so graph[1] = [].
Append 1 to graph[0].
Result: graph = {0: [1], 1: []}.
add_edge(graph, 0, 2):
src = 0, dest = 2.
0 is already in graph.
2 is not in graph, so graph[2] = [].
Append 2 to graph[0].
Result: graph = {0: [1, 2], 1: [], 2: []}.
add_edge(graph, 1, 2):
src = 1, dest = 2.
1 is already in graph.
2 is already in graph.
Append 2 to graph[1].
Result: graph = {0: [1, 2], 1: [2], 2: []}.
add_edge(graph, 2, 3):
src = 2, dest = 3.
2 is already in graph.
3 is not in graph, so graph[3] = [].
Append 3 to graph[2].
Result: graph = {0: [1, 2], 1: [2], 2: [3], 3: []}.
add_edge(graph, 3, 3):
src = 3, dest = 3.
3 is already in graph.
Append 3 to graph[3].
Result: graph = {0: [1, 2], 1: [2], 2: [3], 3: [3]}.
****************************************************************************************
Is there any way we can find that it is a graph question
jis entity ki bat ho rahi hai woh numbred hogi most of times
ex->courses de rakha hai -->n
they are numbred 0 to (n-1)
relation ki bat kar rhi ho ->hinting toward edge of the graph
directly puchuega topic se
***********
from collections import defaultdict
adj = defaultdict(list)
prerequisites = [[1, 0], [2, 0], [3, 1], [3, 2]]
for vec in prerequisites:
    u = vec[0]  # Source node
    v = vec[1]  # Destination node
    adj[u].append(v)  # Add the edge to the adjacency list
for node, neighbors in adj.items():
    print(f"{node} -> {neighbors}")

******************************************************************************************************
Travesal in graph
*******
dfs and bfs
*********
from collections import defaultdict

class Solution:
    
    #Function to return a list containing the DFS traversal of the graph.
    def dfsOfGraph(self, adj):
        # code here
        adjlist=defaultdict(list)
        for i in range(len(adj)):
            for j in range(len(adj[i])):
                adjlist[i].append(adj[i][j])
                
        
        def dfs(adjlist,visited,u):
            visited[u]=True
            ans.append(u)
            for v in adjlist[u]:
                if not visited[v]:
                    dfs(adjlist,visited,v)
            
        
        ans=[]
        visited=[False]*len(adjlist)
        dfs(adjlist,visited,0)
        return ans
***********************************

in dfs traversal the arrow is moving in this way
-> -> -> -> ->
******************************************************************************
bfs is used in shortest path
***********
from collections import defaultdict,deque
from typing import List

class Solution:
    # Function to return Breadth First Traversal of given graph.
    def bfsOfGraph(self, adj: List[List[int]]) -> List[int]:
        adjlist=defaultdict(list)
        for i in range(len(adj)):
            for j in range(len(adj[i])):
                adjlist[i].append(adj[i][j])
                
        
        def bfs(adjlist,visited,u):
            queue=deque()
            queue.append(u)
            visited[u]=True
            
            ans.append(u)
            while(queue):
                u=queue.popleft()
                
                for v in adjlist[u]:
                    if not visited[v]:
                        queue.append(v)
                        visited[v]=True
                        ans.append(v)
                
            
        
        ans=[]
        visited=[False]*len(adj)
        bfs(adjlist,visited,0)
        return ans
***************************************************
GFG
Cycle in a undirected graph using dfs
**********************
from typing import List
from collections import defaultdict
class Solution:
    #Function to detect cycle in an undirected graph.
	def isCycle(self, V: int, adj: List[List[int]]) -> bool:
	    visited=[False]*len(adj)
	    def is_cycle_dfs(adj,visited,u,parent):
	        visited[u]=True
	        for v in adj[u]:
	            if v==parent:
	                continue
	            if visited[v]==True:
	                return True
	            if is_cycle_dfs(adj,visited,v,u):
	                return True
	        return False       
	                
	        
	    for i in range(V):
	        if(not visited[i]):
	            if(is_cycle_dfs(adj,visited,i,-1)):
	                return True
***************************************************************************************************************************************
GFG
Cycle in a undirected graph using bfs
***************************
from typing import List
from collections import defaultdict,deque
class Solution:
    #Function to detect cycle in an undirected graph.
	def isCycle(self, V: int, adj: List[List[int]]) -> bool:
	    visited=[False]*len(adj)
	    def is_cycle_bfs(adj,visited,u):
	        q=deque()
	        q.append((u,-1))
	        visited[u]=True
	        while(q):
	            source,parent=q.popleft()
	            for v in adj[source]:
	                if visited[v]==False:
	                    visited[v]=True
	                    q.append((v,source))
	                elif parent!=v:
	                    return True
	        return False            
	                    
	                
	           
	                
	        
	    for i in range(V):
	        if(visited[i]==False):
	            if(is_cycle_bfs(adj,visited,i)):
	                return True
	    return False
**********************************************
Detect a cycle in a directed graph
********************************
from typing import List

class Solution:
    
    #Function to detect cycle in a directed graph.
    def isCyclic(self, V : int , adj : List[List[int]]) -> bool :
        # code here
        visited=[False]*V
        inRecursion=[False]*V
        def detectCycle(visited,inRecursion,adj,u):
            visited[u]=True
            inRecursion[u]=True
            for v in adj[u]:
                if visited[v]==False and detectCycle(visited,inRecursion,adj,v):
                    return True
                elif(visited[v]==True and inRecursion[v]==True):
                    return True
                    
            inRecursion[u]=False
            return False
                    
                    
        for i in range(V):
            if visited[i]==False:
                if detectCycle(visited,inRecursion,adj,i):
                    return True
        return False
 ******************************************************************************
GRAPH
Topological sort is in directed Acyclic graph---dfs

class Solution:
    
    #Function to return list containing vertices in Topological order.
    def topologicalSort(self,adj):
        visited=[False]*len(adj)
        stack=[]
        def dfs(visited,adj,u):
            visited[u]=True
            for v in adj[u]:
                if visited[v]==False:
                    visited[v]=True
                    dfs(visited,adj,v)
                    
            stack.append(u)        
        for i in range(len(adj)):
            if visited[i]==False:
                
                dfs(visited,adj,i)
        result=[]
        while(stack):
            result.append(stack.pop())
          
        return result    
*********************************************************************************
GRAPH
Topological sort is in directed Acyclic graph----->bfs| kahns algorithm

from collections import deque

class Solution:
    
    #Function to return list containing vertices in Topological order.
    def topologicalSort(self,adj):
        indegree=[0]*len(adj)
        queue=deque()
        for u in range(len(adj)):
           for v in adj[u]:
               indegree[v]=indegree[v]+1
        for i in range(len(indegree)):
            if(indegree[i]==0):
                queue.append(i)
        result=[] 
        while(queue):
            u=queue.popleft()
            result.append(u)
            for v in adj[u]:
                indegree[v]=indegree[v]-1
                if indegree[v]==0:
                    queue.append(v) 
        # print(result)            
        return result            
******************************************************************************************************
Detect cycle in a directed graph using------ bfs
I have used here topological sort concept here since in topological sort graph should be directed and acyclic. if he graph is directed and cyclic then it must be not give the 
topological sort
def isCyclic(self, V : int , adj : List[List[int]]) -> bool :
        # code here
        indegree=[0]*V
        queue=deque()
        count=0
        for u in range(V):
            for v in adj[u]:
                indegree[v]=indegree[v]+1
                
        for i in range(V):
            if indegree[i]==0:
                queue.append(i)
                count=count+1
                
        while(queue):
            u=queue.popleft()
            for v in adj[u]:
                indegree[v]=indegree[v]-1
                if indegree[v]==0:
                    count=count+1
                    queue.append(v)
        if count==V:
            return False
        return True  
