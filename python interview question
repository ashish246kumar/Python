Multiple inheritense in python at deep level
Abstraction in pythn
polymormphism
shallow copy vs deep copy
why tuple is more memory efficient
what is blueprint
priority level of log
what is rest api?
how do you implement jwt
lambda expresion for complex operation like calculating power of number
Explain database connection in Python Flask.
Does Python make use of access specifiers?
Explain how the join() function in Python?
How can you identify and deal with missing values in a dataframe?
What is the use of manage.py in Python?
What method can be used to generate random numbers in Python?
What does *args, **kwargs mean in Python?
Is Flask an MVC model? If true, justify this using the MVC pattern.
How can we check if all characters in a string are alphanumeric?
What are some of the most used built-in modules in Python?
What are the tools for debugging and performing static analysis in Python?
Write a code to add two integers without using the ‘+’ operator when the numbers are greater than zero.
Write a code to create a single string from elements in a list.
Is it possible for a function not to have a return statement and is it valid?
How do you convert string to lowercase in Python?
How do you convert string to lowercase in Python?
What is a Try Block?
Differentiate between override and new modifiers.
In Python, what would you do to create an empty class?
Do you think you can call the parent class without its instance creation?
In what ways can parent members in a child class be accessed?
Why is NumPy preferred over Python lists?
How can you copy an object in Python?
What is shallow and deep copying in Python?
What are Pickling?
How can you define Unpickling in Python?
What function is used for Pickling and Unpickling?
What are some types of Type Conversion in Python?
What is reindexing in Pandas?
How can you remove values from an array in Python?
What do you think is the use of dir () function in Python?
What is Type Conversion in Python?
What are literals in Python?
Can you tell us if Python is object-oriented or functional programming?
What rules govern local and global variables in Python?
What are ODBC modules in Python?
What is PEP 8 and its importance?
What is a scope in Python?
What built-in types are available in Python?
How does a function return values in Python?
What is a Python PATH?
What is a Package in Python?
What is a Package in Python?
What are keywords in Python?
How can you remove values from an array in Python?
Beware: Mutable Types and Shallow Copying
Threading and Python's Global Interpreter Lock
10: Asynchronous Python Programming with Asyncio
Mocking External Dependencies in Python Testing
Q.3. Explain the ternary operator in Python.
Q.5. Is Python case-sensitive?
Q.6. How long can an identifier be in Python?
Q.13. How will you check if all characters in a string are alphanumeric?
With Python, how do you find out which directory you are currently in?
limitation of python
Q.28. How will you convert a list into a string?
Q.32. Explain the //, %, and ** operators in Python.
relational operator in python
*************
Q.35. Explain logical operators in Python.
Multiple conditions check karne ke liye)
x = 5
y = 10

print(x < 10 and y > 5)  # ➔ True (Both conditions True)
print(x > 10 or y > 5)   # ➔ True (One condition True)
print(not(x < 10))       # ➔ False (Opposite result)

***********************************************
Q.36. What are membership operators?
my_list = [1, 2, 3, 4, 5]
print(3 in my_list)    # ➔ True  (3 is in the list)
print(7 not in my_list) # ➔ True  (7 is NOT in the list)

*********
Q.37. Explain identity operators in Python.|  Identity	is, is not x is y (Identity Operators (Do variables same object ko refer karte hain ya nahi?)

*********************************************
Q.38. Finally, tell us about bitwise operators in Python.
print(a & b)   # ➔ 1  (AND)        → 0101 & 0011 = 0001
print(a | b)   # ➔ 7  (OR)         → 0101 | 0011 = 0111
print(a ^ b)   # ➔ 6  (XOR)        → 0101 ^ 0011 = 0110
print(~a)      # ➔ -6 (NOT)        → ~0101 = -(0101+1)
print(a << 1)  # ➔ 10 (Left Shift) → 0101 << 1 = 1010
print(a >> 1)  # ➔ 2  (Right Shift)→ 0101 >> 1 = 0010
*********************************************************************
Q.41. How would you convert a string into an int in Python?
Q.45. What does the function zip() do?
Q.48. How do you get all values from a Python dictionary?
Q.61. How is Python different from Java?
Q.60. What is PEP 8?
Q.62. What is the best code you can write to swap two numbers?
Q.63. How can you declare multiple assignments in one statement?
How will you send an email from a Python Script?
Can you explain what is unittest in Python?





****************************************************************************************************************************
Write a  Python program that implements a decorator to validate function arguments based on a given condition.
*********************************

def validate_arguments(condition):
    def decorator(func):
        def wrapper(*args, **kwargs):
            if condition(*args, **kwargs):
                return func(*args, **kwargs)
            else:
                raise ValueError("Invalid arguments passed to the function")
        return wrapper
    return decorator

@validate_arguments(lambda x: x > 0)
def calculate_cube(x):
    return x ** 3

print(calculate_cube(5))  # Output: 125
print(calculate_cube(-2))  # Raises ValueError: Invalid arguments passed to the function

*************************************************************************************************
 Write a Python program that implements a decorator to cache the result of a function.
****
def cache_result(func):
    cache = {}

    def wrapper(*args, **kwargs):
        key = (*args, *kwargs.items())

        if key in cache:
            print("Retrieving result from cache...")
            return cache[key]

        result = func(*args, **kwargs)
        cache[key] = result

        return result

    return wrapper


# Example usage

@cache_result
def calculate_multiply(x, y):
    print("Calculating the product of two numbers...")
    return x * y

# Call the decorated function multiple times
print(calculate_multiply(4, 5))  # Calculation is performed
print(calculate_multiply(4, 5))  # Result is retrieved from cache
print(calculate_multiply(5, 7))  # Calculation is performed
print(calculate_multiply(5, 7))  # Result is retrieved from cache
print(calculate_multiply(-3, 7))  # Calculation is performed
print(calculate_multiply(-3, 7))  # Result is retrieved from cache


*******************************************************************************************************************
what is the use of @property  annotation?
***********
The @property decorator is used to define a method as a getter for an attribute.
class Circle:
    def __init__(self, radius):
        self._radius = radius  # private variable (convention: use underscore)
    
    # Getter method using @property
    @property
    def radius(self):
        return self._radius

    # Setter method using @radius.setter
    @radius.setter
    def radius(self, value):
        if value < 0:
            raise ValueError("Radius cannot be negative")
        self._radius = value

    # Property method to calculate area, read-only
    @property
    def area(self):
        return 3.14159 * self._radius ** 2

# Create an object of Circle
circle = Circle(5)

# Accessing radius through property (getter)
print(circle.radius)  # Output: 5

# Setting radius via setter
circle.radius = 10
print(circle.radius)  # Output: 10

# Accessing the area (computed property)
print(circle.area)  # Output: 314.159

*****************
why we can not create instanse of abstract class

*********
we can create instanse of  class only when we have the 100 percent of implementation of any method.
*************************
🔹 What Happens If We Try to Instantiate an Abstract Class?
✅ Python throws a TypeError because Animal has an abstract method that is not implemented.
**********
🔹 Can We Instantiate an Abstract Class That Has No Abstract Methods?
print(type(obj))   # ✅ Output: <class '__main__.BaseClass'>
Yes! If an abstract class does not have any abstract methods, Python allows instantiation.
***********
Can We Provide a Definition for an Abstract Method in an Abstract Class?
Yes, we can provide a definition (implementation) for an abstract method in an abstract class. However, the method must still be overridden in the subclass, unless explicitly called using super().

from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def make_sound(self):
        """Providing a default implementation"""
        print("Some generic animal sound")  # Default behavior

class Dog(Animal):
    def make_sound(self):
        super().make_sound()  # Calling abstract method from the base class
        print("Woof! Woof!")  # Dog's specific sound

dog = Dog()
dog.make_sound()
Some generic animal sound
Woof! Woof!
*******************************************************************
since we are providing  defination of abstract method then can we create object
The abstract class remains uninstantiable as long as it has at least one method decorated with @abstractmethod.
*******"
can we create cnstructor inside abstract class
Yes, we can create a constructor (__init__) inside an abstract class in Python. The constructor of the abstract class will be inherited by its subclasses, and they can use super().__init__() to call it.


from abc import ABC, abstractmethod

class Vehicle(ABC):  
    def __init__(self, brand):
        self.brand = brand  # Instance variable
    
    @abstractmethod
    def start(self):
        pass

class Car(Vehicle):
    def __init__(self, brand, model):
        super().__init__(brand)  # Calling the constructor of abstract class
        self.model = model

    def start(self):
        print(f"{self.brand} {self.model} is starting...")

# Creating an object of the subclass
car = Car("Tesla", "Model S")
car.start()  
print(car.brand)  # ✅ Tesla
print(car.model)  # ✅ Model S




**********************************************************************************
        A  →  Parent Class
       / \
      B   C → Child Classes  -hirarchial

2. How to use super() in Multiple Inheritance?

Python supports multiple inheritance using a left-to-right method resolution order (MRO), following the C3 Linearization Algorithm.

class A:
    def show(self):
        print("A's show")

class B(A):
    def show(self):
        print("B's show")
        super().show()

class C(A):
    def show(self):
        print("C's show")
        super().show()

class D(B, C):  # Inherits from B and C, both inherit from A
    def show(self):
        print("D's show")
        super().show()  # Uses MRO to avoid calling A multiple times

obj = D()
obj.show()

D's show
B's show
C's show
A's show

*************
class A:
    def show(self):
        print("A's show")

class B(A):
    def show(self):
        print("B's show")
        super().show()  # Calls A's show()

class C(B):
    def show(self):
        print("C's show")
        super().show()  # Calls B's show()

obj = C()
obj.show()

C's show
B's show
A's show

***********************************************************************************************
class A:
    def show(self):
        print("Show method from A")

class B:
    def show(self):
        print("Show method from B")

class C(A, B):  # A comes first, so A's show() is called
    pass

obj = C()
obj.show()
Show method from A
*******
class C(A, B):
    def show(self):
        B.show(self)  # Explicitly calling B's method

obj = C()
obj.show()
*********
Show method from B
****************************************************
class X:
    def display(self):
        print("X method")

class Y(X):
    def display(self):
        print("Y method")
        super().display()

class Z(Y):
    def display(self):
        print("Z method")
        super().display()

class W(Z):
    def display(self):
        print("W method")
        super().display()

obj = W()
obj.display()
********
W method
Z method
Y method
X method
*************************************************************************
class A:
    def show(self):
        print("Show method from A")

class B:
    def show(self):
        print("Show method from B")

class C(A, B):   
    def show(self): 
        B.show(self)  # Explicitly calling B's method

obj = C()
obj.show()
*********
Show method from B

*****************************






































****************************************************************************************************************
difference between module and package?
 📦 Module vs Package in Python (HinEnglish)
Aspect	                                      Module	                                                                  Package
Definition	Ek Python file (.py) jisme functions, classes, aur variables hote hain.  	Ek folder jisme multiple modules ya sub-packages hote hain.
File Type	Simple .py file	                                                                 Folder with __init__.py file (Python 3.3+ me optional)
Purpose	        Code ko reuse aur organize karne ke liye.	                                      Badi applications ko structure aur organize karne ke liye.
Example	            math.py, re.py	                                                           numpy, pandas jisme kai modules hote hain.
Import Syntax	import math	                                                                import package.module
Hierarchy	Single level	                                                              Multi-level hierarchy possible (sub-packages)
**********
# file: calculator.py
def add(a, b):
    return a + b

# Importing:
import calculator
print(calculator.add(2, 3))  # ➔ 5

    from math_operations import addition
print(addition.add(5, 3))  # ➔ 8

**************
is python compiled language or interpreted language?
python is interpreted language.That means python code is executed line by line by an interpreter at runtime . rather than being compiled into machine code beforehand like in compile language
**********
what are the benefit of using python lanuage as a tool in present scenario?
simplicity|portability|open source|strong community support|development speed|dynamic typing|Extensive library and framework like django,numpy,pandas
***********************************************************************************************************************************
what are the global protected and private attribute in python?
Global variable are the public variable defined in the global scope . to use global variable inside a function global keyword is used
protected attribute are marked with single _underscore while they can still be accessed and modified from outside the class responsible developer should avoid doing so
private variable are marked with double underscore (__ansh) . these can not be modified or accessed directly from outside the class and any such event will result an attribute error
*****************************************************************************************************************************************
what is pandas
Pandas ek Python library hai jo data analysis aur data manipulation ke liye use hoti hai. 
Ye structured data (jaise tables, Excel files, CSVs) ko handle karne ke liye powerful tools provide karti hai.
 Key Data Structures:
Series → 1D (Single column data)
DataFrame → 2D (Rows aur columns wala data, like Excel table)


**************************************************************************************************************************
How exception handling is done in python
The main keyword for handling exception are try, except, finnaly .
*******************************************************************************************************************************
what is the use of self in python
self is used to represent instance of the class. with this keyword you can access the attribute and method of class in python binding the attribute with provided argument

***************************************************************************************************************************
How is memory management done in Python?
python manages memory using a private heap space where all objects and datastrcture stored . Programmers can not directly access this private heap . it is managed by python inter
preter. Aditionally python has built in grabage collector that automatically recycles unused memory , freeing it up and making it available for future use
*************************************************************************************************************************************************************
How to delete a file using Python?
we can delete a file using python by the following approach 
os.remove(),os.unlink()
**********************************************************************************************************************************
Which sorting technique is used by sort() and sorted() functions of python?
python uses Tim sort algorithm for sortig which is stable sorting method with worst case time complexity of O(NlogN). Time sort is a hybrid algorithm derived from merged 
sort and insertion sort designed to perform efficienty on various type of real data
***************************************************
Differentiate between List and Tuple?
list-> syntax->[],mutability->mutable,Modification-> can change, add,remove, methods->append(),remove(), Access->indexing, usage-> mutuable collection , memory efficiecy->
less efficient, hashability-> not hashable
tuple-> syntax->(),mutability->Immutable,Modification-> can not change, methods-count(), index(), Access->[index], usage->constannt data , memory efficiecy->
more efficient, hashability->  hashable
*******************************************************************************************************************************************************
What is slicing in Python?
python slicig is a operation used to extract a portion of the string or list. by  specifying start, end and step you can determine the exact segment to extract
slicing a list result in a new list created from specified portion of the original list

***************************************************************************************
8. How is multithreading achieved in Python?
Multithreading in python is achieved using the threadig module which enable the concurrent execution of multiple thread within a single process. Each thread can run its own code
and perform task simoltaneously
**************************************************************************************************
‘#’ is used to comment on everything that comes after on the line
Use the # symbol for single-line comments.
you can use triple quotes (''' or """) to write multi-line comments
***********
Mutable data types can be edited i.e., they can change at runtime. Eg – List, Dictionary, etc.
Immutable data types can not be edited i.e., they can not change at runtime. Eg – String, Tuple, etc.
*************************************************************
The set is unordered collection of unique items that is iterable and mutable. A dictionary in Python is an ordered collection of data values, 
used to store data values like a map.
 *******************************************************************************************
List comprehension is a syntax construction to ease the creation of a list based on existing iterable.
For Example:
my_list = [i for i in range(1, 10)]
***************************************************************************
## Lambda
A lambda function is an anonymous function. This function can have any number of parameters but, can have just one statement. For Example:
a = lambda x, y : x*y
print(a(7, 19))
**********************************************************************************
. What is a pass in Python?
Pass means performing no operation or in other words, it is a placeholder in the compound statement, where there should be a blank left and nothing has to be written there.
**********************
15. Can we Pass a function as an argument in Python?

Yes, Several arguments can be passed to a function, including objects, variables (of the same or distinct data types), and functions
 Higher-order functions are functions that can take other functions as arguments.

*********************************************************************************************************************************************
19. What is docstring in Python?
documentation strings (or docstrings) provide a convenient way of associating documentation with Python modules, functions, classes, and methods.


Declaring Docstrings: The docstrings are declared using ”’triple single quotes”’ or “””triple double quotes””” just below the class, method, or function declaration.
 All functions should have a docstring
Accessing Docstrings: The docstrings can be accessed using the __doc__ method of the object or using the help function
*********************************************************************************************************************************************************
Dictionary Comprehension? 
For Example: my_dict = {i:i+7 for i in range(1, 10)}
*******************************************
24. What is the difference between xrange and range functions?

range() and xrange() are two functions that could be used to iterate a certain number of times in for loops in Python. 

In Python 3, there is no xrange, but the range function behaves like xrange
**************************************************************************************

Differentiate between List and Tuple?

List

Lists are Mutable datatype.
Lists consume more memory
The list is better for performing operations, such as insertion and deletion.
The implication of iterations is Time-consuming
Tuple

Tuples are Immutable datatype.
Tuple consumes less memory as compared to the list
A Tuple data type is appropriate for accessing the elements
The implication of iterations is comparatively Faster
********************************************************************************************************************************************************
how do you debug a Python program?
By using this command we can debug a Python program:

$ python -m pdb python-script.py
**************************
34. Does Python supports multiple Inheritance?
Python does support multiple inheritances, unlike Java. Multiple inheritances mean that a class can be derived from more than one parent class.
Python uses the Method Resolution Order (MRO) to determine the order in which methods are inherited and executed. The MRO is based on the C3 linearization algorithm.

*************************************************************
 How do you do data abstraction in Python?
Data Abstraction is providing only the required details and hides the implementation from the world. It can be achieved in Python by using interfaces and abstract classes.
from abc import ABC, abstractmethod

# Abstract base class
class Animal(ABC):
    @abstractmethod
    def sound(self):
        pass

    @abstractmethod
    def move(self):
        pass

# Subclass that implements the abstract methods
class Dog(Animal):
    def sound(self):
        return "Bark"
    
    def move(self):
        return "Run"

# Subclass that implements the abstract methods
class Bird(Animal):
    def sound(self):
        return "Chirp"
    
    def move(self):
        return "Fly"

# This will raise an error because Animal is an abstract class
# animal = Animal()  # TypeError: Can't instantiate abstract class Animal with abstract methods sound, move

# Correct usage
dog = Dog()
print(dog.sound())  # Output: Bark
print(dog.move())   # Output: Run

bird = Bird()
print(bird.sound())  # Output: Chirp
print(bird.move())   # Output: Fly

***************
38. How is memory management done in Python?
Python uses its private heap space to manage the memory. Basically, all the objects and data structures are stored in the private heap space. 
Even the programmer can not access this private space as the interpreter takes care of this space. Python also has an inbuilt garbage collector, 
which recycles all the unused memory and frees the memory and makes it available to the heap space.
********************************************************************************
48. What are Access Specifiers in Python?
Python uses the ‘_’ symbol to determine the access control for a specific data member or a member function of a class.
 A Class in Python has three types of Python access modifiers:
Public Access Modifier,Private Access Modifier,Protected Access Modifier
**************************************************************************************
51. What are Function Annotations in Python?

Function Annotation is a feature that allows you to add metadata to function parameters and return values.
 This way you can specify the input type of the function parameters and the return type of the value the function returns.

*************************************************************************************
differece between list and dict
list--> list object are created using list() function| The default order of element is always maintained| we can access the element using the index value
|placeing all the element inside the square bracket seperated by comma| List are collection of various element (Hetrogeneous)
dict-->dictionary object are created using dict() function| No gurantee of maintaning the order| we can access the element using the key| placing all the key value inside 
the curly braces
****************************************************************************************************************************
differece between apped and extend property of list?
append--> appeds() adds an element to the list | the length of the list will increase by one
extend--> extend() concatenates the first list with another list/iterable| The length of the list will increase by hoever many element were in the iterable argument
eg 
list1=[1,2,3]
list2=[4,5,6]
list1.append("AB")-->print(list1)--->[1,2,3,"AB"]-->in case append "AB" is treated as object
list2.extend("AB")-->print(list2)-->[4,5,6,"A","B"]-->
list1.append(list2)-->[1,2,3,[4,5,6]]
list1.append(list2)-->[1,2,3,4,5,6]
list1.append(4)-->[1,2,3,4]
list1.extend(4)-->it will throw error since 4 is not iterable object
*****************************************************************************************
 can we use list/tuple or list inside a tuple as a key in dictionary?
no list can not be used as a key in dictionary| tuple can be used as key in dictionary|no tuple contaning list can not be used as a key in dictionary
Dictionaries are indexed by keys.
Those Keys can be any immutable type i.e strings and numbers can always be keys. 
You can’t use lists as keys, since lists can be modified in place using index assignments
*****************************************************
Why Python Is Called As Dynamic Typed Programming  Language OR What Is Duck Typing?
Python don't have any problem even if we don't declare the type of variable. 
It states the kind of variable in the runtime of the program. 
Python also take cares of the memory management which is crucial in programming. So, Python is a dynamically typed language.
*********************************************************************
6. What If We Don't Use “With” Statement
If We Don't use "WITH" Statement, We need to close the opened file manually but using close().
In Case Of open():
file = open("hello.txt", "w")
file.write("Hello, World!")
file.close()
# Safely open the file
file = open("hello.txt", "w")
try:
    file.write("Hello, World!")
finally:
    file.close()
****
with open("hello.txt", "w") as file:
    file.write("Hello, World!")
************
 Internal functions called in "WITH" Statement

.__enter__() is called by the with statement to enter the runtime context.
.__exit__() is called when the execution leaves the with code block
****************************************************************************************************************************
  Q)What is Abstraction And How To Define Abstract Classes and Functions Using Abstraction.
An abstract base class is the common application program of the interface for a set of subclasses. 
It can be used by the third-party, which will provide the implementations such as with plugins.

Working of the Abstract Classes:
Unlike the other high-level language, Python doesn't provide the abstract class itself. We need to import the abc module, which provides the base for 
defining Abstract Base classes (ABC). The ABC works by decorating methods of the base class as abstract. It registers concrete classes as the implementation of
 the abstract base. We use the @abstractmethod decorator to define an abstract method or if we don't provide the definition to the method, it automatically
becomes the abstract method. Let's understand the following example.

Steps to Create and Use Abstract Classes:
Import the abc module.
Create a base class that inherits from ABC.
Use the @abstractmethod decorator to declare abstract methods.
Implement the abstract methods in derived (concrete) classes.


from abc import ABC, abstractmethod

# Abstract Base Class
class Plugin(ABC):
    @abstractmethod
    def execute(self):
        """Run the plugin's main functionality."""
        pass

    @abstractmethod
    def configure(self, settings):
        """Configure the plugin with specific settings."""
        pass

# Concrete Class implementing the Abstract Base Class
class VideoPlugin(Plugin):
    def execute(self):
        print("Executing Video Plugin functionality.")

    def configure(self, settings):
        print(f"Configuring Video Plugin with settings: {settings}")

# Another Concrete Class
class AudioPlugin(Plugin):
    def execute(self):
        print("Executing Audio Plugin functionality.")

    def configure(self, settings):
        print(f"Configuring Audio Plugin with settings: {settings}")


# Client Code
def run_plugin(plugin: Plugin):
    plugin.configure({"quality": "high"})
    plugin.execute()

# Test the plugins
video_plugin = VideoPlugin()
audio_plugin = AudioPlugin()

run_plugin(video_plugin)
run_plugin(audio_plugin)

*****************************************************************************************
what is PYTHON PATH?
PYTHONPATH is an environment variable in Python that specifies a list of directories the Python interpreter should add to its module search path
This allows you to import modules from directories not in Python's default locations.

export PYTHONPATH=/path/to/my/modules:/another/path

**********
Try: This block will test the exceptional error to occur.

Except: Here you can handle the error.

Else: If there is no exception then this block will be executed.

********************************************************************************************************************************
PIP
pip is the package manager for Python packages. We can use pip to install packages that do not come with Python
******************************************************
28. How to use F String and Format or Replacement Operator?
name = 'Nitin'
role = 'Python Developer'
print(f"Hello, My name is {name} and I'm {role}")
#How To Use format Operator

name = 'Nitin'
role = 'Python Developer'
print(("Hello, My name is {} and I'm {}").format(name,role))

Output:
Hello, My name is Nitin and I'm Python Developer
********************************************************************************************************************
29. How to Get List of all keys in a Dictionary?
Using List:
dct = {'A': 1, 'B': 2, 'C': 3}
all_keys = list(dct.keys())
print(all_keys)  # ['A', 'B', 'C']

Shortcut for Above Code:
dct = {'A': 1, 'B': 2, 'C': 3}
all_keys = list(dct)
print(all_keys)  # ['A', 'B', 'C']
***********************************************************************
30. Difference Between Abstraction and Encapsulation.
Abstraction------> Abstraction works on the design level.|Abstraction is implemented to hide unnecessary data and withdrawing relevant data.|


Encapsulation----->Encapsulation works on the application level.| Encapsulation is the mechanism of hiding the code and the data 
together from the outside world or misus | Encapsulation is supported using, e.g. public, private and secure 
access modification systems.
************************************************************
31. Does Python Support Multiple Inheritance. (Diamond Problem)
Yes, Python Supports Multiple Inheritance.
ultiple Inheritance In Python:


class A:
	def abc(self):
		print("a")

class B(A):
	def abc(self):
		print("b")

class C(A):
	def abc(self):
		print("c")

class D(B,C):
	pass

d = D()
d.abc()
**********************************************************************************
Empty List:
a = []

Empty Tuple:
a = ()

Empty Dict:
a = {}

Empty Set:
a = set()
*************************************************************************
33. Difference Between .py and .pyc
.py files contain the source code of a program. Whereas, .pyc file contains the bytecode of your program.
Python compiles the .py files and saves it as .pyc files , so it can reference them in subsequent invocations. 
The .pyc contain the compiled bytecode of Python source files. This code is then executed by Python's virtual machine .
**********************************************************************************************************************************
 Can You Concatenate Two Tuples. If Yes, How Is It Possible?        Since it is Immutable
How To Concatenate Two Tuple:

t1 = (1,2,3)
t2 = (7,9,10)
t1 = t1 + t2
print("After concatenation is : ", t1 )

Output:
After concatenation is :  (1, 2, 3, 7, 9, 10)



The expression t1 + t2 creates a new tuple by concatenating the elements of t1 and t2.
This new tuple is then assigned back to the variable t1.
The original t1 tuple is not modified; instead, the variable t1 now points to the new tuple created by concatenation.
The immutability of tuples means that the original t1 object remains unchanged, but since t1 is just a variable name (a reference), it can be reassigned to point to
a new object
print("ID of t1 before:", id(t1))  # ID of the original t1
t1 = t1 + t2
print("ID of t1 after:", id(t1))   # ID of the new t1
*****************************************************************
38. How To Read Multiple Values From Single Input?
By Using Split()
x = list(map(int, input("Enter a multiple value: ").split()))
print("List of Values: ", x)

x = [int(x) for x in input("Enter multiple value: ").split()]
print("Number of list is: ", x)

x = [int(x) for x in input("Enter multiple value: ").split(",")]
print("Number of list is: ", x)
**********************************************
where to use module and where to use package

Larger projects: If your application has multiple modules, group them into packages for better organization.
Hierarchical structure: When you need to group related modules into logical units or categories.

**********************************************************************************************************************************************
*
difference between class and static method and instance method


Feature	                              Instance Method	                                            Class Method	                             Static Method
Decorator	                       None (default)	                                             @classmethod	                             @staticmethod
First Argument	                   self (instance reference)	                                   cls (class reference)	                  No mandatory argument
Can Access Instance Variables?	          ✅ Yes	                                                  ❌ No	                                        ❌ No
Can Access Class Variables?	          ✅ Yes	                                                  ✅ Yes	                                ❌ No
Can Modify Class Variables?	          ✅ Yes	                                                  ✅ Yes	                                ❌ No
Bound To	                          Object (instance)	                                          Class	                            Class (but doesn’t use cls)
When to Use?	When the method needs to access instance attributes	When working with class-level data, not specific instances	When the method is independent of instance and class

*********************************************************************************************************************************************

SQLite is a lightweight, self-contained, serverless SQL database engine that is built into Python via the sqlite3 module. 
It is widely used for local database storage and testing due to its simplicity and ease of use.

import sqlite3
Connecting to a Database
Use sqlite3.connect() to create a connection to an SQLite database.
If the database file does not exist, it will be created.
python
Copy code
conn = sqlite3.connect("example.db")  # Creates or connects to 'example.db'
*************************************************************************************
wat is supper function in python and where it is used

super is used to call parent class constructor from child class  or parent class method from child class
**
class Parent:
    def __init__(self, name):
        self.name = name

class Child(Parent):
    def __init__(self, name, age):
        super().__init__(name)  # Calls Parent's constructor
        self.age = age

# Test
child = Child("Ashish", 25)
print(child.name)  # Output: Ashish
print(child.age)   # Output: 25
**
class Parent:
    def greet(self):
        print("Hello from the Parent class!")

class Child(Parent):
    def greet(self):
        super().greet()  # Calls the parent class method
        print("Hello from the Child class!")

# Test
child = Child()
child.greet()

****************************
what is casting in python?

type of casting
implicit :
Explicit:
**************
if we want to access the keys of dictonary how i can is there any method?
yes we can using dict.keys()

**********************************************************************

In Python, a namespace is a mapping from names to objects. It's a way to organize code and avoid naming conflicts by associating unique names with specific objects
Think of a namespace as a dictionary where the keys are the names and the values are the corresponding objects (like variables, functions, classes, etc.)

Built-in Namespace: This namespace contains all the built-in functions and objects in Python, such as print(), len(), and int.
Global Namespace: This namespace contains names defined at the level of the main program.
Local Namespace: The local namespace refers to the scope inside a function or method
Enclosing Namespace: This namespace refers to variables that are in the outer function's scope, but not global. 
Namespace Resolution in Python (LEGB Rule)

*****************
what is the importance of writing __main__ method in python ?

if __name__ == "__main__": construct is not strictly necessary to write code, but it's considered 
a best practice  
In Python, the "if name == 'main' " construct is used to control whether a piece of code should run when a script is executed directly as a program or when it is imported as a module into another script;
essentially, it acts as a guard to ensure that certain code only runs when the script is the main entry point, preventing unintended execution when imported as a module.

Key points about __main__:
How it works:
When you run a Python script, the special variable __name__ is set to "__main__" within that script. If you import the script as a module into another script, __name__ will be set to the module's name instead.

Example
*****
main_script.py

def greet():
    print("Hello from main_script!")

if __name__ == "__main__":
    print("main_script.py is being run directly!")
    greet()

*****
another_script.py
import main_script

print("another_script.py is running!")
main_script.greet()

The if __name__ == "__main__" block in main_script.py does not execute because main_script is imported as a module (and __name__ in main_script is set to "main_script", not "__main__").

********************
what is the purpose of self inside method can we replace with any other name
In Python, self is a convention used to represent the instance of the class. It is used within instance methods to refer to the object that is calling the method.
Yes, you can technically replace self with any other name.  but it is highly discouraged because it goes against Python conventions and may cause confusion
***************************
create a class that has attribute and method and try to access method outide the class

****************************************
what is the importance of indentation in python?

Importance of Indentation in Python:
1. Defines Code Blocks
2. Improves Code Readability
4. Shows Hierarchy and Logic

**********
what is difference between slicing and indexing

*********
what are the python string replacement

str.replace(old, new, count)
text = "hello world, hello Python"
result = text.replace("hello", "hi")
print(result)  # Output: "hi world, hi Python"

# With `count`
result = text.replace("hello", "hi", 1)
print(result)  # Output: "hi world, hello Python"

or 
import re

text = "hello 123 world 456"
# Replace digits with 'X'
result = re.sub(r"\d+", "X", text)
print(result)  # Output: "hello X world X"
                  
****
if we are using regular expression then any package i need to import

you need to import the re module
re.match(pattern, string)
Checks for a match only at the beginning of the string
re.search(pattern, string)
Searches the entire string for the first occurrence of the pattern
*****
if we want to play date and time how i can
date is not actual python data type we need import a module datetime to work with date 
***************
different types of function in python
 Higher-order Functions
Description: Functions that take other functions as arguments or return them as results.
Examples:
map()
filter()

 Anonymous Functions (Lambda Functions)
Description: Functions defined without a name using the lambda keyword.
add = lambda x, y: x + y
print(add(3, 5))  # Output: 8


********
what is the difference between python list and array
in python terminology we called list and in case odf java we called array
*****************
pass-->no action required
*******
what are the basic setuprequire before writing python progrm
****************************************************************************************************************************************************
what do you mean by suits in python?

suites refer to a block of code that is grouped together and intended to execute as a single unit under a control structure 
such as an if statement, for/while loop, function definition, or class definition.
*******************************************************
how we can concenate two tuple

# Example of tuple concatenation
tuple1 = (1, 2, 3)
tuple2 = (4, 5, 6)

# Concatenating tuples
result = tuple1 + tuple2
print(result)
Tuples are immutable, so concatenation creates a new tuple rather than modifying the original ones.

*************************************************
self is used to refer to the instance of that particular object
*************
reg expression are used for matching pattern
********
what do you mean by agaile methodology
******************************************************************
@pytest.fixture is a decorator in Python's pytest testing framework. 
It is used to define reusable setup code that can be shared across multiple test functions.
 Fixtures help in preparing the test environment, such as creating necessary objects, setting up resources, or configuring dependencies.

This is a decorator provided by pytest. It tells pytest that the following function is a fixture,
 which means it is a reusable piece of code that sets up something needed for your tests 
*******************************************************************************************************************************************************************
app.test_client()

test_client() is a Flask method that creates a test client.
This client is used to simulate HTTP requests (like GET, POST, etc.) to your Flask app, without actually starting a server.
For example, you can use this client to call your API endpoints in a test.
**********************************************************************************************************************************************************
What is an Application Context?
Think of your Flask app as a big factory. Inside this factory, you have tools and resources (like a database, configuration settings, etc.) that your app uses.

The application context is like a "toolbox" that contains these tools for your app. But here's the thing: you need to "open the toolbox" to actually use the tools.

What Does with app.app_context() Do?
When you write with app.app_context():, you are opening the toolbox temporarily so you can access the resources (like the database or app settings) for the work you're about to do.

***********************
@patch('app.models.maintenance_form.MaintenanceForm.query')
The @patch decorator is used to "fake" the database query.
It replaces the actual MaintenanceForm.query with a mock object (mock_query) during the test. This way, no real database calls are made, which makes the test faster and more isolated.

mock_query.all.return_value = mock_tickets
This line tells the mock query to return the mock_tickets list whenever .all() is called.
*************************************************************************************************
terms, mock_paginate = MagicMock() creates a fake object that can act like anything you want it to. Think of it as a blank slate or a "dummy helper" you can use to imitate something real.

For example:

Imagine you’re practicing how to serve a customer in a restaurant.
Instead of practicing with real food, you use fake plastic food.
The MagicMock is like that fake food—it stands in for something real (like a database object) so you can practice or test your process without involving the real thing.
**************************
from unittest.mock import patch
import pytest
*********************************************************************************************************************
why tuples are memory efficient but list are not
tuples are stored as fixed arrays, while lists have a more complex structure to support resizing and modifications.
Tuples are stored in contiguous memory blocks, making them cache-friendly. Lists, due to their dynamic nature, may have elements scattered in memory.


**********************************************************
Why Use Blueprints?
Modularization – Helps break large applications into smaller, manageable components.
Reusability – You can reuse blueprints across multiple applications.
Scalability – Makes it easier to add new features without cluttering the main app.
Better Code Organization – Keeps related functionality together (e.g., authentication, user management, etc.).
**********************************************************************************************
l1 = [1, 8, 2, 3, 4, 6]
output = []

for i in range(len(l1)):
    if i + l1[i] > len(l1):  
        output.append([0])  # If index goes out of bounds, append [0]
    else:
        output.append(l1[i:i + l1[i]])

# Print the output in the desired format
for item in output:
    print(item)
***************************************************************************************************

import copy

# Original list with nested elements
original_list = [[1, 2, 3], [4, 5, 6]]

# Create a shallow copy
shallow_copied_list = copy.copy(original_list)

# Modify the nested list
shallow_copied_list[0][0] = 99

# Both lists reflect the change in the nested list
print("Original List:", original_list)  
print("Shallow Copied List:", shallow_copied_list)

*******
import copy

# Original list with nested elements
original_list = [[1, 2, 3], [4, 5, 6]]

# Create a deep copy
deep_copied_list = copy.deepcopy(original_list)

# Modify the nested list
deep_copied_list[0][0] = 99

# Only the copied list is affected
print("Original List:", original_list)  
print("Deep Copied List:", deep_copied_list)
***************************************************************************************************



