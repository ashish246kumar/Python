search-a-2d-matrix

You are given an m x n integer matrix matrix with the following two properties:
Each row is sorted in non-decreasing order.
The first integer of each row is greater than the last integer of the previous row.
Given an integer target, return true if target is in matrix or false otherwise.
You must write a solution in O(log(m * n)) time complexity.


Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false

class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        n=len(matrix)
        m=len(matrix[0])
        l=0
        h=(n*m)-1
        mid=0
        while(l<=h):
            mid=(l+h)//2
            row=mid//m
            col=mid%m
            if matrix[row][col]==target:
                return True
            elif matrix[row][col]<target:
                l=mid+1
            else:
                h=mid-1
        return False           


***********************************************
240
search-a-2d-matrix-ii
Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:
Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.
 
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        r=0
        m=len(matrix[0])-1
        n=len(matrix)-1
        c=m
        while(r<=n and c>=0):
            if matrix[r][c]==target:
                return True
            elif matrix[r][c]<target:
                r+=1
            else:
                c=c-1
        return False            
*******************************************************************************************
254 spiral-matrix                
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        m=len(matrix)
        n=len(matrix[0])
        srow=0
        scol=0
        erow=m-1
        ecol=n-1
        l1=[]
        while srow<=erow and scol<=ecol:
            # top
            for i in range(scol,ecol+1):
                l1.append(matrix[srow][i])

            # right
            for j in range(srow+1,erow+1): 
                l1.append(matrix[j][ecol])
            #bottom
            if srow<erow:
                for j in range(ecol-1,scol-1,-1): 
                   
                    l1.append(matrix[erow][j])
            #left
            if scol<ecol:
                for j in range(erow-1,srow,-1): 
                   
                    l1.append(matrix[j][scol]) 
            srow+=1
            scol+=1
            ecol-=1
            erow-=1                
        return l1
 
******************************************
Rotate-image
**********************************
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        n=len(matrix)
        m=len(matrix[0])
        for i in range(n):
            for j in range(i+1,n):
                temp=matrix[i][j]
                matrix[i][j]=matrix[j][i]
                matrix[j][i]=temp
        l1=m//2
        for i in range(n):
            k=m-1 
            for j in range(l1):
                temp=matrix[i][j]
                matrix[i][j]=matrix[i][k]
                matrix[i][k]=temp
                k=k-1       
        """
        Do not return anything, modify matrix in-place instead.
        """
*******************************************************************************************************************************
498
Diagonal Traverse
Input: mat = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,4,7,5,3,6,8,9]
Example 2:

Input: mat = [[1,2],[3,4]]
Output: [1,2,3,4]
 *******
for up arrow (i+j) is same for same diagonal
and for down array (i-j) is same for diagonal

****************************************************************************
class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
        dict1={}
        n=len(mat)
        m=len(mat[0])
        for i in range(n):
            for j in range(m):
                if i+j not in dict1:
                    dict1[i+j]=[mat[i][j]]
                else:
                    dict1[i+j].append(mat[i][j])

        print(dict1)            
        ans=[]             
        for entry in dict1.items():
            if entry[0]%2==0:
                [ans.append(x) for x in entry[1][::-1]]
            else:
                [ans.append(x) for x in entry[1]]

        return ans
*******************************************************************************************************************************



                
        
        


 

