There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.
A province is a group of directly or indirectly connected cities and no other cities outside of the group.
You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.
Return the total number of provinces.
********************************************************************************************************
 Example 1:
Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]
Output: 2
Example 2:
Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]
Output: 3
 class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        adjlist=defaultdict(list)
        n=len(isConnected)
        visited=[False]*n
        count=0
        def dfs(isConnected,visited,u):
            visited[i]=True
            for v in range(n):
                if visited[v]==False and isConnected[u][v]==1:
                    visited[v]=True
                    dfs(isConnected,visited,v)

      
        for i in range(n):
            if visited[i]==False:
                dfs(isConnected,visited,i)
                count=count+1
        return count        
***********************************************************************************
Course Schedule

There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return true if you can finish all courses. Otherwise, return false.

 

Example 1:

Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
Example 2:

Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.

***********************
here i have done this question throgh topological sort using bfs.  if we are able to find topological sort then we are able to cmplete the course other qwise not
*********
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        indegree=[0]*numCourses
        n=len(prerequisites)
        queue=deque()
        count=0
        adj=defaultdict(list)
        for i in range(n):
            a=prerequisites[i][0]
            b=prerequisites[i][1]
            adj[b].append(a)
            indegree[a]=indegree[a]+1
        for i in range(numCourses):
            if indegree[i]==0:
                queue.append(i)
                count=count+1
        while(queue):
            u=queue.popleft()
            for v in  adj[u]:
                indegree[v]=indegree[v]-1
                if indegree[v]==0:
                    queue.append(v)
                    count=count+1
        if count==numCourses:
            return True
        return False                 
***************************************************************************************
785
Is-graph-bipartite

There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:

There are no self-edges (graph[u] does not contain u).
There are no parallel edges (graph[u] does not contain duplicate values).
If v is in graph[u], then u is in graph[v] (the graph is undirected).
The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.
A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.

Return true if and only if it is bipartite.

 

Example 1:


Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
Output: false
Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.
Example 2:


Input: graph = [[1,3],[0,2],[1,3],[0,2]]
Output: true
Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.

***************88
class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        adj=defaultdict(list)
        n=len(graph)
        color=[-1]*n
        for i in range(n):
            for j in range(len(graph[i])):
                adj[i].append(graph[i][j])
        def dfs(adj,color,currNode,currentColor):
            color[currNode]=currentColor
            for v in adj[currNode]:
                if color[currNode]==color[v]:
                    return False
                if color[v]==-1:
                    colorV=1-color[currNode] 
                    if dfs(adj,color,v,colorV)==False:
                        return False
            return True            


        for i in range(n):
            if color[i]==-1:
                if dfs(adj,color,i,1)==False:
                    return False       
        return True
                            
**************************************************************************************************************************

GRAPH-->DSU
satisfiability-of-equality-equations
**********************************************************************
You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: "xi==yi" or "xi!=yi".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.

Return true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.
Example 1:

Input: equations = ["a==b","b!=a"]
Output: false
Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.
There is no way to assign the variables to satisfy both equations.
Example 2:

Input: equations = ["b==a","a==b"]
Output: true
Explanation: We could assign a = 1 and b = 1 to satisfy both equations.

******************************************************************
class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        parent=[i for i in range(26)]
        rank=[0]*26
        def find(u):
            if parent[u]==u:
                return u
            parent[u]=find(parent[u]) 
            return parent[u]
        def union(x,y):
            x_p=parent[x]
            y_p=parent[y] 
            if rank[x_p]>rank[y_p]:
                parent[y_p]=x_p
            elif rank[x_p]<rank[y_p]:
                parent[x_p]=y_p
            else:
                parent[x_p]=y_p
                rank[y_p]+=1
        for s in equations:
            x=ord(s[0])-ord('a')
            y=ord(s[3])-ord('a')
            if s[1] =='=':
                
                union(x,y)
        
        for s in equations:
            x=ord(s[0])-ord('a')
            y=ord(s[3])-ord('a')
            if s[1] =='!':
                print(find(x))
                print(find(y))
                if find(x)==find(y):
                    return False
        return True                
************************************************************************************************
**************************************************************************************************************************

GRAPH-->DSU
number-of-operations-to-make-network-connected
**************************************************************************************************************************
There are n computers numbered from 0 to n - 1 connected by ethernet cables connections forming a network where connections[i] = [ai, bi] represents a connection between computers ai and bi. Any computer can reach any other computer directly or indirectly through the network.
You are given an initial computer network connections. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.
Return the minimum number of times you need to do this in order to make all the computers connected. If it is not possible, return -1.
Example 1:
Input: n = 4, connections = [[0,1],[0,2],[1,2]]
Output: 1
Explanation: Remove cable between computer 1 and 2 and place between computers 1 and 3.
Example 2:
Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
Output: 2
Example 3:
Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]
Output: -1
Explanation: There are not enough cables.




class Solution:
    def makeConnected(self, n: int, connections: List[List[int]]) -> int:
        length=len(connections)
        
        if length<(n-1):
            return -1
        parent=[i for i in range(n)]    
        rank=[0]*n
        component=n
        def find(u):
            if parent[u]==u:
                return u
            parent[u]=find(parent[u]) 
            return parent[u]
        def union(x,y):
            x_p=find(x)
            y_p=find(y)
            if x_p==y_p:
                return
            if rank[x_p]>rank[y_p]:
                parent[y_p]=x_p
            elif rank[x_p]<rank[y_p]:
                parent[x_p]=y_p
            else:
                parent[x_p]=y_p
                rank[y_p]+=1
        for v in connections:
            a=v[0]
            b=v[1]
            if find(a)!=find(b):
                   component-=1
                   union(a,b)   
        return component-1             
****************************************************************************************************************************
2316   DSU
count-unreachable-pairs-of-nodes-in-an-undirected-graph
***************************************************
You are given an integer n. There is an undirected graph with n nodes, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.
Return the number of pairs of different nodes that are unreachable from each other.
Example 1:
Input: n = 3, edges = [[0,1],[0,2],[1,2]]
Output: 0
Explanation: There are no pairs of nodes that are unreachable from each other. Therefore, we return 0.
Example 2:
Input: n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]
Output: 14
Explanation: There are 14 pairs of nodes that are unreachable from each other:
[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]].
Therefore, we return 14.

*****************************************************************************************************************************
class Solution:
    def countPairs(self, n: int, edges: List[List[int]]) -> int:
        parent=[i for i in range(n)]
        rank=[0]*n
        dict1={}
        def find(u):
            if parent[u]==u:
                return u
            parent[u]=find(parent[u]) 
            return parent[u]
        def union(x,y):
            x_p=find(x)
            y_p=find(y) 
            if x_p==y_p:
                return
            if rank[x_p]>rank[y_p]:
                parent[y_p]=x_p
            elif rank[x_p]<rank[y_p]:
                parent[x_p]=y_p
            else:
                parent[x_p]=y_p
                rank[y_p]+=1
        for v in edges:
            union(v[0],v[1])  
        for i in range(n):
            papa=find(i)
            dict1[papa]=dict1.get(papa,0)+1
             
          
        result=0
        remaning=n
        for key in dict1:
            size=dict1[key]
            
            result+=size*(remaning-size)
            remaning=remaning-size
        return result    
***************************************************************************************************************************************************

**************************************************************************************************************************************************
743
Network-delay-time->Throujh dijkastra
*******************************************
You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.
We will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.
Example 1:
Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
Output: 2
Example 2:
Input: times = [[1,2,1]], n = 2, k = 1
Output: 1
Example 3:
Input: times = [[1,2,1]], n = 2, k = 2
Output: -1
*********************

class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        adj=defaultdict(list)
        for v in times:
            adj[v[0]].append((v[1],v[2]))
        pq=[]
        heapq.heappush(pq,(0,k))
        result=[sys.maxsize]*(n+1)
        result[k]=0
        while(pq):
            d,node=heapq.heappop(pq)
            for v in adj[node]:
                adjNode,dist=v
                if d+dist<result[adjNode]:
                    result[adjNode]=d+dist
                    heapq.heappush(pq,(d+dist,adjNode))

        ans = -sys.maxsize - 1 
        
        for i in range(1,n+1):
            ans=max(ans,result[i])
        if ans==sys.maxsize:
            return -1
        return ans        
******************************************************************************************************************************************************
1091  BFS 
 shortest-path-in-binary-matrix:-it can be solved throgh both bfs and dijkastra 
we can solve any question of shortest path thrugh bfs if weight is same.


Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.
A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:
All the visited cells of the path are 0.
All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).
The length of a clear path is the number of visited cells of this path.
Example 1:
Input: grid = [[0,1],[1,0]]
Output: 2
Example 2:
Input: grid = [[0,0,0],[1,1,0],[1,1,0]]
Output: 4
Example 3:
Input: grid = [[1,0,0],[1,1,0],[1,1,0]]
Output: -1
*****************
class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        queue=deque()
        m=len(grid)
        n=len(grid[0])
        directions=[(1,1),(1,0),(0,1),(-1,-1),(-1,0),(0,-1),(-1,1),(1,-1)]
        def isSafe(x,y):
            return x>=0 and x<m and y>=0 and y<n
        if m==0 or n==0 or grid[0][0]!=0:
            return -1
        queue.append((0,0))
        step=1
        while (queue):
            N=len(queue)
            while N>0:
                N=N-1
                x,y=queue.popleft()
                if x==m-1 and y==n-1:
                    return step
                for dir in directions:
                    a,b=dir
                    x_=x+a
                    y_=y+b
                    if isSafe(x_,y_) and grid[x_][y_]==0:
                        queue.append((x_,y_))
                        grid[x_][y_]=1 
            step=step+1               
        return -1
                
********************************************************************
    Example 2:
Input: grid = [[0,0,0],[1,1,0],[1,1,0]]
Output: 4    

que= (0,0)
   step=1
   m=3
   n=3
  grid[0][0]=1
*********
pop-> x,y=0,0
x_=0
   y_=1
   grid[0][1]=1
   queue=(0,1)
   step=2
*************
pop-> x,y=0,1
x_=0
y_=2
grid[0][2]=1
queue=(0,2)
****
x_=1
y_=2
grid[1][2]=1
queue=(0,2),(1,2)
step=3
****
queue=(0,2)(1,2)
pop-> x,y=0,2->can not go anywhere from here because everewhere is 1
pop-> x,y=1,2
 
x_=2
y_=2
grid[2][2]=1
queue=(2,2)
step=4
***********
pop->x,y=2,2
x_=2
y_=2
return step
*******************************************************************
        

