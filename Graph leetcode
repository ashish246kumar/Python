There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.
A province is a group of directly or indirectly connected cities and no other cities outside of the group.
You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.
Return the total number of provinces.
********************************************************************************************************
 Example 1:
Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]
Output: 2
Example 2:
Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]
Output: 3
 class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        adjlist=defaultdict(list)
        n=len(isConnected)
        visited=[False]*n
        count=0
        def dfs(isConnected,visited,u):
            visited[i]=True
            for v in range(n):
                if visited[v]==False and isConnected[u][v]==1:
                    visited[v]=True
                    dfs(isConnected,visited,v)

      
        for i in range(n):
            if visited[i]==False:
                dfs(isConnected,visited,i)
                count=count+1
        return count        
***********************************************************************************
Course Schedule

There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return true if you can finish all courses. Otherwise, return false.

 

Example 1:

Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
Example 2:

Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.

***********************
here i have done this question throgh topological sort using bfs.  if we are able to find topological sort then we are able to cmplete the course other qwise not
*********
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        indegree=[0]*numCourses
        n=len(prerequisites)
        queue=deque()
        count=0
        adj=defaultdict(list)
        for i in range(n):
            a=prerequisites[i][0]
            b=prerequisites[i][1]
            adj[b].append(a)
            indegree[a]=indegree[a]+1
        for i in range(numCourses):
            if indegree[i]==0:
                queue.append(i)
                count=count+1
        while(queue):
            u=queue.popleft()
            for v in  adj[u]:
                indegree[v]=indegree[v]-1
                if indegree[v]==0:
                    queue.append(v)
                    count=count+1
        if count==numCourses:
            return True
        return False                 
***************************************************************************************
785
Is-graph-bipartite

There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:

There are no self-edges (graph[u] does not contain u).
There are no parallel edges (graph[u] does not contain duplicate values).
If v is in graph[u], then u is in graph[v] (the graph is undirected).
The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.
A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.

Return true if and only if it is bipartite.

 

Example 1:


Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
Output: false
Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.
Example 2:


Input: graph = [[1,3],[0,2],[1,3],[0,2]]
Output: true
Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.

***************88
class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        adj=defaultdict(list)
        n=len(graph)
        color=[-1]*n
        for i in range(n):
            for j in range(len(graph[i])):
                adj[i].append(graph[i][j])
        def dfs(adj,color,currNode,currentColor):
            color[currNode]=currentColor
            for v in adj[currNode]:
                if color[currNode]==color[v]:
                    return False
                if color[v]==-1:
                    colorV=1-color[currNode] 
                    if dfs(adj,color,v,colorV)==False:
                        return False
            return True            


        for i in range(n):
            if color[i]==-1:
                if dfs(adj,color,i,1)==False:
                    return False       
        return True
                            
**************************************************************************************************************************

GRAPH-->DSU
satisfiability-of-equality-equations
**********************************************************************
You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: "xi==yi" or "xi!=yi".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.

Return true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.
Example 1:

Input: equations = ["a==b","b!=a"]
Output: false
Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.
There is no way to assign the variables to satisfy both equations.
Example 2:

Input: equations = ["b==a","a==b"]
Output: true
Explanation: We could assign a = 1 and b = 1 to satisfy both equations.

******************************************************************
class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        parent=[i for i in range(26)]
        rank=[0]*26
        def find(u):
            if parent[u]==u:
                return u
            parent[u]=find(parent[u]) 
            return parent[u]
        def union(x,y):
            x_p=parent[x]
            y_p=parent[y] 
            if rank[x_p]>rank[y_p]:
                parent[y_p]=x_p
            elif rank[x_p]<rank[y_p]:
                parent[x_p]=y_p
            else:
                parent[x_p]=y_p
                rank[y_p]+=1
        for s in equations:
            x=ord(s[0])-ord('a')
            y=ord(s[3])-ord('a')
            if s[1] =='=':
                
                union(x,y)
        
        for s in equations:
            x=ord(s[0])-ord('a')
            y=ord(s[3])-ord('a')
            if s[1] =='!':
                print(find(x))
                print(find(y))
                if find(x)==find(y):
                    return False
        return True                
************************************************************************************************
**************************************************************************************************************************

GRAPH-->DSU
number-of-operations-to-make-network-connected
**************************************************************************************************************************
There are n computers numbered from 0 to n - 1 connected by ethernet cables connections forming a network where connections[i] = [ai, bi] represents a connection between computers ai and bi. Any computer can reach any other computer directly or indirectly through the network.
You are given an initial computer network connections. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.
Return the minimum number of times you need to do this in order to make all the computers connected. If it is not possible, return -1.
Example 1:
Input: n = 4, connections = [[0,1],[0,2],[1,2]]
Output: 1
Explanation: Remove cable between computer 1 and 2 and place between computers 1 and 3.
Example 2:
Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
Output: 2
Example 3:
Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]
Output: -1
Explanation: There are not enough cables.




class Solution:
    def makeConnected(self, n: int, connections: List[List[int]]) -> int:
        length=len(connections)
        
        if length<(n-1):
            return -1
        parent=[i for i in range(n)]    
        rank=[0]*n
        component=n
        def find(u):
            if parent[u]==u:
                return u
            parent[u]=find(parent[u]) 
            return parent[u]
        def union(x,y):
            x_p=find(x)
            y_p=find(y)
            if x_p==y_p:
                return
            if rank[x_p]>rank[y_p]:
                parent[y_p]=x_p
            elif rank[x_p]<rank[y_p]:
                parent[x_p]=y_p
            else:
                parent[x_p]=y_p
                rank[y_p]+=1
        for v in connections:
            a=v[0]
            b=v[1]
            if find(a)!=find(b):
                   component-=1
                   union(a,b)   
        return component-1             
****************************************************************************************************************************
2316   DSU
count-unreachable-pairs-of-nodes-in-an-undirected-graph
***************************************************
You are given an integer n. There is an undirected graph with n nodes, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.
Return the number of pairs of different nodes that are unreachable from each other.
Example 1:
Input: n = 3, edges = [[0,1],[0,2],[1,2]]
Output: 0
Explanation: There are no pairs of nodes that are unreachable from each other. Therefore, we return 0.
Example 2:
Input: n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]
Output: 14
Explanation: There are 14 pairs of nodes that are unreachable from each other:
[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]].
Therefore, we return 14.

*****************************************************************************************************************************
class Solution:
    def countPairs(self, n: int, edges: List[List[int]]) -> int:
        parent=[i for i in range(n)]
        rank=[0]*n
        dict1={}
        def find(u):
            if parent[u]==u:
                return u
            parent[u]=find(parent[u]) 
            return parent[u]
        def union(x,y):
            x_p=find(x)
            y_p=find(y) 
            if x_p==y_p:
                return
            if rank[x_p]>rank[y_p]:
                parent[y_p]=x_p
            elif rank[x_p]<rank[y_p]:
                parent[x_p]=y_p
            else:
                parent[x_p]=y_p
                rank[y_p]+=1
        for v in edges:
            union(v[0],v[1])  
        for i in range(n):
            papa=find(i)
            dict1[papa]=dict1.get(papa,0)+1
             
          
        result=0
        remaning=n
        for key in dict1:
            size=dict1[key]
            
            result+=size*(remaning-size)
            remaning=remaning-size
        return result    
***************************************************************************************************************************************************

        

        
